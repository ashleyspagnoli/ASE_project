\section{Security}

\subsection{Security – Data}

\subsubsection{Input Sanitization}

\textbf{Selected Input:} User email addresses during registration and modification.

\paragraph{Description:}
The email input is a critical user identifier used for account recovery and communication. It must be sanitized to prevent:
\begin{itemize}
    \item NoSQL injection attacks
    \item Cross-site scripting (XSS) attempts
    \item Duplicate account creation
\end{itemize}

\paragraph{Microservices Involved:}
\begin{itemize}
    \item \textbf{User-Manager:} Handles registration and email validation
    \item \textbf{User-Editor:} Manages email modification requests
    \item \textbf{API Gateway:} Performs initial validation before forwarding requests
\end{itemize}

\paragraph{Sanitization Strategy:}

\textbf{Type Validation:}
\begin{lstlisting}
class UserCreate(UserBase):
    password: str = Field(..., min_length=3)
    email: str = Field(..., description="User's email")
\end{lstlisting}

\textbf{Hash-based Duplicate Prevention:}
\begin{lstlisting}
def hash_search_key(data: str) -> str:
    """SHA-256 hash for consistent, secure searching"""
    return hashlib.sha256(data.lower().encode('utf-8')).hexdigest()

# Usage in registration
hashed_email = hash_search_key(user_in.email)
if USERS_COLLECTION.find_one({"hashed_email": hashed_email}):
    raise HTTPException(status_code=400, 
                       detail="Email already registered")
\end{lstlisting}

\textbf{Query Parameter Validation:}
\begin{lstlisting}
# Explicit type enforcement prevents injection
page = request.args.get('page', default=0, type=int)
\end{lstlisting}

\subsubsection{Data Encryption at Rest}

\paragraph{Encrypted Data:}
To protect confidentiality in case of database compromise email addresses and usernames in user-db have been encrypted at rest. 

\paragraph{Encryption Implementation:}

\textbf{Encryption Method:} Fernet

\textbf{Key Management:}
\begin{itemize}
    \item Encryption key stored as Docker secret at \texttt{/run/secrets/user\_db\_encryption\_secret\_key}
    \item Generated using cryptographically secure random bytes (32 bytes/256 bits)
    \item Encoded in Base64 URL-safe format for compatibility
\end{itemize}

\textbf{Encryption Location:} \texttt{user-manager} microservice

\textbf{Usage in Data Storage:}
\begin{lstlisting}
# main.py - User registration
user_data = {
    "username": user_in.username,
    "email": encrypt_data(user_in.email),  # Encrypted before storage
    "hashed_password": get_password_hash(user_in.password), # Hashed password+salt
    "hashed_email": hash_search_key(user_in.email)
}
USERS_COLLECTION.insert_one(user_data)
\end{lstlisting}

\textbf{Decryption Location:} \texttt{user-manager} microservice (during token validation and user data retrieval)

\begin{lstlisting}
# Automatic decryption when retrieving user data
user = UserInDB(
    username=user_doc['username'],
    email=decrypt_data(user_doc['email']),  # Decrypted on read
    hashed_password=user_doc['hashed_password']
)
\end{lstlisting}

\paragraph{Reasons:}
\begin{itemize}
    \item \textbf{Defense in Depth:} Even if the database is compromised, sensitive data remains encrypted
    \item \textbf{Dual Hashing Strategy:} Email addresses are both encrypted (for storage) and hashed (for duplicate checking), preventing inference attacks
    \item \textbf{Separation of Concerns:} Encryption keys are managed externally via Docker secrets
\end{itemize}

\newpage
\subsection{Security – Authentication and Authorization}

\subsubsection{Architecture: Centralized Authentication}

Our system implements a \textbf{centralized authentication model} where the \texttt{user-manager} microservice acts as the single source of truth for authentication and token validation.

\paragraph{Token Validation Flow:}

\begin{enumerate}
    \item \textbf{Client Request:} User sends credentials to API Gateway
    \item \textbf{Authentication:} API Gateway forwards to \texttt{user-manager}
    \item \textbf{Token Generation:} \texttt{user-manager} creates JWT and returns to client
    \item \textbf{Subsequent Requests:} Client includes JWT in Authorization header
    \item \textbf{Token Validation:} Each microservice calls \texttt{user-manager} to validate token
    \item \textbf{Authorization:} Microservice proceeds with request if token is valid
\end{enumerate}

\begin{figure}[h]
\centering
\begin{minipage}{0.9\textwidth}
\textbf{Token Validation Process:}
% \begin{verbatim}
% ┌─────────┐        ┌─────────────┐        ┌──────────────┐
% │ Client  │───1───>│ API Gateway │───2───>│ Microservice │
% └─────────┘        └─────────────┘        └──────────────┘
%      │                                            │
%      │                                            │3. Validate
%      │                                            ▼
%      │                                     ┌──────────────┐
%      │<──────────────6. Response──────────│ user-manager │
%      │                                     └──────────────┘
%      │                                            │
%      │                                            │4. JWT decode
%      │                                            │5. DB lookup
% \end{verbatim}
\end{minipage}
\caption{Centralized token validation architecture}
\end{figure}

\paragraph{Key Management and Storage:}

\begin{table}[h]
\centering
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Aspect} & \textbf{Implementation} \\ \midrule
\textbf{Signing Key} & 256-bit secret key (HS256 algorithm) \\
\textbf{Storage Location} & Docker secret: \texttt{/run/secrets/jwt\_secret\_key} \\
\textbf{Access Control} & Only \texttt{user-manager} container has read access \\
\textbf{Generation} & Cryptographically secure random bytes (Base64 URL-safe) \\
\textbf{Rotation Strategy} & Manual rotation via Docker secret update and container restart \\ \bottomrule
\end{tabular}
\caption{JWT signing key management}
\end{table}

\subsubsection{Access Token Payload Format}

\begin{lstlisting}
{
  "sub": "username",                 # Subject (username identifier)
  "username": "john_doe",            # Explicit username field
  "id": "507f1f77bcf86cd799439011",  # MongoDB ObjectId
  "exp": 1735220400                  # Expiration timestamp (Unix epoch)
}
\end{lstlisting}

\textbf{Field Descriptions:}
\begin{itemize}
    \item \texttt{sub}: Standard JWT subject claim containing the username
    \item \texttt{username}: Redundant field for backward compatibility
    \item \texttt{id}: User's unique database identifier for efficient lookups
    \item \texttt{exp}: Expiration timestamp (30 minutes from issuance)
\end{itemize}

\subsubsection{Token Generation Process}

\begin{lstlisting}
def create_access_token(data: dict):
    to_encode = data.copy()
    # Ensure 'sub' claim for OAuth2 compatibility
    if "sub" not in to_encode and "username" in to_encode:
        to_encode["sub"] = to_encode["username"]
    
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
\end{lstlisting}

\subsubsection{Expired Token Handling}

\paragraph{Strategy:} \textbf{Automatic rejection with explicit error messaging}

\textbf{Mechanism:}
\begin{enumerate}
    \item JWT library (\texttt{pyJWT}) automatically validates \texttt{exp} claim during decoding
    \item \texttt{JWTError} exception is raised if token is expired
    \item Client receives HTTP 401 Unauthorized response
    \item Client must re-authenticate to obtain new token
\end{enumerate}

\begin{lstlisting}
def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid credentials",
        headers={"Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:  # Catches ExpiredSignatureError automatically
        raise credentials_exception
    
    user = get_user(username)
    if user is None:
        raise credentials_exception
    return user
\end{lstlisting}

\textbf{Client-Side Handling:}
\begin{itemize}
    \item Client detects 401 response
    \item Redirects user to login page
    \item Clears stored token from local state
    \item User re-authenticates to receive fresh token
\end{itemize}

\textbf{No Token Refresh Mechanism:}
For simplicity and security, we do not implement refresh tokens. Users must re-authenticate after 30 minutes of inactivity. This reduces the attack surface by limiting token lifetime.

\newpage
\subsection{Security – Analyses}

\subsubsection{Static Analysis with Bandit}

Bandit was used to perform static application security testing on the Python codebase.

\textbf{Command executed:}
\begin{lstlisting}
bandit -r src/
\end{lstlisting}
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{bandit.png}
\end{figure}

% Da aggiungre screenshot del report di Bandit
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{bandit_report.png}
% \caption{Bandit static analysis final summary}
% \end{figure}

\subsubsection{Dependency Vulnerability Scanning}

\paragraph{Pip Audit:}
Executed as a github action.
It found vulnerabilities before but not after merging the Dependabot pull request.

\paragraph{Dependabot (GitHub):}
Enabled on the repository to automatically scan for vulnerable dependencies.

\begin{itemize}
    \item Updates python-multipart from 0.0.9 to 0.0.18
    \item Updates requests from 2.31.0 to 2.32.4
    \item Updates cryptography from 42.0.7 to 44.0.1
\end{itemize}
This also solved issues raised by pip-audit

\subsubsection{Container Image Vulnerability Analysis}

\paragraph{Docker Scout:}

\textbf{Usage:} all container images where scanend for vulnerabilities using Docker Scout directly from Docker Desktop.

\textbf{Mitigation Actions:}
\begin{itemize}
    \item \textbf{RabbitMQ:} 2 critical, 9 high-severity vulnerabilities because of the golang and stdlib versions in the linux image used by 3-management. Solved upgrading to \texttt{rabbitmq:4.2.1-alpine}.
    \item \textbf{MongoDB:}
    This was more of an issue, 
    \begin{itemize}
        \item The mongo:latest image we used in development had 6 high-severity vulnerabilities.
        \item All the versions of the official mongo image have either a lot of vulnerabilities or run only on windows servers (windows OS images).
        \item "latest" images are not an option as a final shipment version, this would mean the images possibly breaking for an update.
        \item All the companies we've found providing mongo linux images moved to a paid model, providing only "latest" versions for free for development environments.
        \item The only option we had were old legacy images made by those companies in the past.
        Fortunately we found \textit{circleci/mongo:4.0-xenial-ram},
        a 4 years old image that relied on a really light-weight ubuntu version with 0 vulnerabilities.
        \item This is definitely not a future-proof solution. The best path forward would probably be to build a custom image where we install mongoDB on top of a lightweight alpine or debian image.
    \end{itemize}
    \item \textbf{JWT:} The User Manager microservice used an abandoned library to handle the JWT called python-jose with a high severity vulnerability. Fortunately there was a new and updated library that had the same functions, called PyJWT.
    \item FastAPI 0.111.0 has critical vulnerabilities caused by a starlette dependency. Solved by upgrading to 0.124.4.
    \item python:3.12.3-slim has critical vulnerabilities caused by the debian image used. Solved by upgrading to 3.12.12-slim.
\end{itemize}

% Da aggiungere screenshot del report di Docker Scout
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{docker_scout_dashboard.png}
% \caption{Docker Scout vulnerability dashboard}
% \end{figure}

\paragraph{Trivy:}

\textbf{Command executed:}
\begin{lstlisting}
trivy image --severity HIGH,CRITICAL <image_name>
\end{lstlisting}

\textbf{Findings:}
\begin{itemize}
    \item \textbf{Exposed Secrets:} Trivy detected hardcoded keys in repository
    \item \textbf{Academic Context:} As agreed with the Professor, keys are intentionally included since it's a project with educational purposes. In a real context, we wouldn't have published neither keys on the GitHub repository, neither the databases passwords in the docker compose file, but we would've passed passwords as environment variables and used certificates provided by CAs stored locally and added to .gitignore.
    \item \textbf{Production Mitigation:} In a real deployment, keys would be:
    \begin{itemize}
        \item Generated dynamically per environment
        \item Stored in secure secret management systems
        \item Never committed to version control
    \end{itemize}
\end{itemize}


\subsection{Security – Threat Model}

\subsubsection{Architecture Overview}
The application follows a microservices architecture with a centralized API Gateway acting as the single entry point. All inter-service communication is secured via TLS.

\begin{itemize}
    \item \textbf{External Entry Point:} API Gateway (exposed on port 8443).
    \item \textbf{Internal Services:} User Manager, User Editor, Game Engine, Game History, Collection.
    \item \textbf{Data Stores:} Dedicated MongoDB instances for Users, History, and Decks.
    \item \textbf{Messaging:} RabbitMQ for asynchronous communication, configured to reject non-TLS connections.
\end{itemize}

\subsubsection{Assets Identification}
\begin{itemize}
    \item \textbf{User Credentials:} Passwords (hashed) and Emails (encrypted).
    \item \textbf{Session Tokens:} JWTs used for authentication.
    \item \textbf{Game Data:} Match history and player moves.
    \item \textbf{Infrastructure Secrets:} TLS certificates and private keys managed via Docker Secrets.
\end{itemize}

\subsubsection{STRIDE Analysis}

\paragraph{Spoofing}
\begin{itemize}
    \item \textbf{Threat:} An attacker impersonating a legitimate user.
    \item \textbf{Mitigation:} Strong authentication via \texttt{user-manager}, JWT validation on every request, and TLS for all connections to prevent credential interception.
    \item \textbf{Threat:} A rogue service impersonating a legitimate microservice.
    \item \textbf{Mitigation:} Internal TLS usage with certificates managed via Docker Secrets ensures encrypted communication channels.
\end{itemize}

\paragraph{Tampering}
\begin{itemize}
    \item \textbf{Threat:} Modification of game results or user data in transit.
    \item \textbf{Mitigation:} End-to-end TLS encryption prevents Man-in-the-Middle (MitM) attacks.
    \item \textbf{Threat:} Modification of data at rest.
    \item \textbf{Mitigation:} Critical user data (emails) is encrypted at rest. Database access is restricted to specific microservices.
\end{itemize}

\paragraph{Repudiation}
\begin{itemize}
    \item \textbf{Threat:} A user denying they performed an action (e.g., a game move).
    \item \textbf{Mitigation:} The \texttt{game\_history} service logs all match outcomes. Actions are authenticated via JWT, linking them irrefutably to a user ID.
\end{itemize}

\paragraph{Information Disclosure}
\begin{itemize}
    \item \textbf{Threat:} Leaking sensitive user information.
    \item \textbf{Mitigation:} Data minimization (only necessary data returned), encryption of sensitive fields in DB, and strict API Gateway routing preventing direct access to backend services.
\end{itemize}

\paragraph{Denial of Service (DoS)}
\begin{itemize}
    \item \textbf{Threat:} Overwhelming the system with requests.
    \item \textbf{Mitigation:} The API Gateway acts as a buffer. RabbitMQ decouples heavy processing (like history logging) from the critical path, preventing cascading failures.
\end{itemize}

\paragraph{Elevation of Privilege}
\begin{itemize}
    \item \textbf{Threat:} A regular user accessing administrative functions.
    \item \textbf{Mitigation:} Centralized authorization logic in \texttt{user-manager}. The API Gateway enforces route restrictions.
\end{itemize}

