\section{Security}

\subsection{Security – Data}

\subsubsection{Input Sanitization}
\textbf{Target:} User email addresses (Registration/Modification).

\textbf{Threats Mitigated:} NoSQL injection, XSS, Duplicate accounts.

\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Type Validation:} Pydantic models enforce strict typing (e.g., \texttt{email: str}).
    \item \textbf{Duplicate Prevention:} SHA-256 hashing of emails for secure, consistent search keys without exposing raw data.
    \item \textbf{Query Safety:} Explicit type casting of query parameters (e.g., \texttt{page=int}) to prevent injection.
\end{itemize}

\subsubsection{Data Encryption at Rest}
\textbf{Scope:} Sensitive user data (Email, Username) in \texttt{user-db}.

\textbf{Mechanism:}
\begin{itemize}
    \item \textbf{Algorithm:} Fernet (Symmetric encryption).
    \item \textbf{Key Management:} 32-byte cryptographically secure key, stored as Docker secret (\texttt{/run/secrets/user\_db\_encryption\_secret\_key}).
    \item \textbf{Process:} 
    \begin{itemize}
        \item \textbf{Write:} Encrypt data before insertion.
        \item \textbf{Read:} Decrypt data on retrieval.
        \item \textbf{Search:} Use hashed values for lookups to avoid decrypting entire collections.
    \end{itemize}
\end{itemize}

\subsection{Security – Authentication and Authorization}

\subsubsection{Architecture}
\textbf{Model:} Centralized Authentication via \texttt{user-manager}.

\textbf{Flow:}
\begin{enumerate}
    \item \textbf{Login:} Client credentials $\rightarrow$ API Gateway $\rightarrow$ \texttt{user-manager} $\rightarrow$ JWT issued.
    \item \textbf{Access:} Client sends JWT $\rightarrow$ Microservice $\rightarrow$ Validate with \texttt{user-manager}.
\end{enumerate}

\subsubsection{Passwords hashing}
The Argon2 algorithm used for password hashing already implements double hashing with salt.

\subsubsection{JWT Implementation}
\textbf{Configuration:}
\begin{itemize}
    \item \textbf{Algorithm:} HS256.
    \item \textbf{Secret Storage:} Docker secret (\texttt{/run/secrets/jwt\_secret\_key}), accessible only to \texttt{user-manager}.
    \item \textbf{Payload:}
    \begin{itemize}
        \item \texttt{sub}: Username (Subject).
        \item \texttt{id}: Database ObjectId.
        \item \texttt{exp}: Expiration timestamp (30 minutes).
    \end{itemize}
\end{itemize}

\subsubsection{Token Lifecycle}
\begin{itemize}
    \item \textbf{Validation:} \texttt{pyJWT} library automatically verifies signature and expiration.
    \item \textbf{Expiration Policy:} For simplicity and security, we do not implement refresh tokens. Users must re-authenticate after 30 minutes of inactivity. This reduces the attack surface by limiting token lifetime.
    \item \textbf{Error Handling:} Expired/Invalid tokens return HTTP 401, triggering client-side logout.
\end{itemize}

\newpage
\subsection{Security – Analyses}

\subsubsection{Static Analysis with Bandit}

Bandit was used to perform static application security testing on the Python codebase.

\textbf{Command executed:}
\begin{lstlisting}
bandit -r src/
\end{lstlisting}
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{images/bandit.png}
\end{figure}

% Da aggiungre screenshot del report di Bandit
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{bandit_report.png}
% \caption{Bandit static analysis final summary}
% \end{figure}

\subsubsection{Dependency Vulnerability Scanning}

\paragraph{Pip Audit:}
Executed as a github action.
It found vulnerabilities before but not after merging the Dependabot pull request.

\paragraph{Dependabot (GitHub):}
Enabled on the repository to automatically scan for vulnerable dependencies.

\begin{itemize}
    \item Updates python-multipart from 0.0.9 to 0.0.18
    \item Updates requests from 2.31.0 to 2.32.4
    \item Updates cryptography from 42.0.7 to 44.0.1
\end{itemize}
This also solved issues raised by pip-audit

\subsubsection{Container Image Vulnerability Analysis}

\paragraph{Docker Scout:}

\textbf{Usage:} all container images where scanend for vulnerabilities using Docker Scout directly from Docker Desktop.

\textbf{Mitigation Actions:}
\begin{itemize}
    \item \textbf{RabbitMQ:} 2 critical, 9 high-severity vulnerabilities because of the golang and stdlib versions in the linux image used by 3-management. Solved upgrading to \texttt{rabbitmq:4.2.1-alpine}.
    \item \textbf{MongoDB:}
    This was more of an issue, 
    \begin{itemize}
        \item The mongo:latest image we used in development had 6 high-severity vulnerabilities.
        \item All the versions of the official mongo image have either a lot of vulnerabilities or run only on windows servers (windows OS images).
        \item "latest" images are not an option as a final shipment version, this would mean the images possibly breaking for an update.
        \item All the companies we've found providing mongo linux images moved to a paid model, providing only "latest" versions for free for development environments.
        \item The only option we had were old legacy images made by those companies in the past.
        Fortunately we found \textit{circleci/mongo:4.0-xenial},
        a 4 years old image that relied on a really light-weight ubuntu version with 0 vulnerabilities.
        \item This is definitely not a future-proof solution. The best path forward would probably be to build a custom image where we install mongoDB on top of a lightweight alpine or debian image.
    \end{itemize}
    \item \textbf{JWT:} The User Manager microservice used an abandoned library to handle the JWT called python-jose with a high severity vulnerability. Fortunately there was a new and updated library that had the same functions, called PyJWT.
    \item FastAPI 0.111.0 has critical vulnerabilities caused by a starlette dependency. Solved by upgrading to 0.124.4.
    \item python:3.12.3-slim has critical vulnerabilities caused by the debian image used. Solved by upgrading to 3.12.12-slim.
\end{itemize}

% Da aggiungere screenshot del report di Docker Scout
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{docker_scout_dashboard.png}
% \caption{Docker Scout vulnerability dashboard}
% \end{figure}

\paragraph{Trivy:}

\textbf{Command executed:}
\begin{lstlisting}
trivy image --severity HIGH,CRITICAL <image_name>
\end{lstlisting}

\textbf{Findings:}
\begin{itemize}
    \item \textbf{Exposed Secrets:} Trivy detected hardcoded keys in repository
    \item \textbf{Academic Context:} As agreed with the Professor, keys are intentionally included since it's a project with educational purposes.
    \item \textbf{Production Mitigation:} In a real deployment, keys would be:
    \begin{itemize}
        \item Generated dynamically per environment or, even better, we could've used certificates provided by a CA.
        \item Stored in secure secret management systems
        \item Never committed
    \end{itemize}
    The same principles would apply for databases passwords hardcoded in the docker compose file.
\end{itemize}


\subsection{Security – Threat Model}

\subsubsection{Assets}
\begin{itemize}
    \item \textbf{User Credentials}:
    \begin{itemize}
        \item Passwords (hashed with Argon2).
        \item Emails (encrypted with Fernet).
    \end{itemize}
    \item \textbf{Session Tokens}: JWTs (HS256) used for stateless authentication.
    \item \textbf{Game Data}:
    \begin{itemize}
        \item Match history (MongoDB \texttt{db-history}).
        \item Deck collections (MongoDB \texttt{db-decks}).
    \end{itemize}
    \item \textbf{Infrastructure Secrets}:
    \begin{itemize}
        \item TLS Certificates and Private Keys (mounted via Docker Secrets).
        \item Database Encryption Keys.
        \item JWT Secret Key.
    \end{itemize}
\end{itemize}

\subsubsection{Attack Surface}
\begin{itemize}
    \item \textbf{API Gateway (Port 8443)}: The single external entry point. Exposes REST endpoints for authentication, game logic, and user management.
    \item \textbf{RabbitMQ Management Interface (Port 15672)}: Exposed only to localhost (127.0.0.1), used for monitoring message queues.
    \item \textbf{Internal Service Ports (Port 5000)}: Not exposed to the host network, but accessible within the \texttt{guerra-ase} Docker network.
\end{itemize}

\subsubsection{Trust Boundaries}
\begin{itemize}
    \item \textbf{External Client / API Gateway}: The primary boundary. All external traffic must pass through the Gateway, which enforces TLS.
    \item \textbf{API Gateway / Internal Microservices}: Traffic is forwarded over HTTPS. The Gateway verifies service certificates against the local certificates.
    \item \textbf{Microservices / Databases}: Services connect to their respective MongoDB instances. Credentials are provided via environment variables.
    \item \textbf{Microservices / RabbitMQ}: Asynchronous communication is secured via TLS and username/password authentication.
\end{itemize}

\subsubsection{STRIDE Analysis}
\begin{itemize}
    \item \textbf{Spoofing}:
    \begin{itemize}
        \item \textit{Threat}: Impersonating a user.
        \item \textit{Mitigation}: JWT authentication required for all protected endpoints. Tokens are signed with a secret key known only to \texttt{user-manager}.
        \item \textit{Threat}: Impersonating a microservice.
        \item \textit{Mitigation}: Internal communication uses TLS. Services must present a valid certificate signed by the internal CA.
    \end{itemize}
    
    \item \textbf{Tampering}:
    \begin{itemize}
        \item \textit{Threat}: Modifying game moves or history in transit.
        \item \textit{Mitigation}: End-to-end TLS encryption (Client $\rightarrow$ Gateway $\rightarrow$ Service).
        \item \textit{Threat}: Modifying user data at rest.
        \item \textit{Mitigation}: Sensitive fields (emails) are encrypted in the database.
    \end{itemize}
    
    \item \textbf{Repudiation}:
    \begin{itemize}
        \item \textit{Threat}: User denying a match result.
        \item \textit{Mitigation}: The \texttt{game\_history} service logs all match outcomes to a persistent MongoDB database.
    \end{itemize}
    
    \item \textbf{Information Disclosure}:
    \begin{itemize}
        \item \textit{Threat}: Leaking user emails.
        \item \textit{Mitigation}: Emails are stored as Fernet-encrypted strings.
        \item \textit{Threat}: Leaking internal architecture via error messages.
        \item \textit{Mitigation}: The API Gateway catches internal exceptions and returns generic HTTP errors to the client.
    \end{itemize}
    
    \item \textbf{Denial of Service}:
    \begin{itemize}
        \item \textit{Threat}: Overloading the system with requests.
        \item \textit{Mitigation}: The API Gateway acts as a reverse proxy. Heavy operations (like history logging) are offloaded to RabbitMQ to prevent blocking the main application flow.
    \end{itemize}
    
    \item \textbf{Elevation of Privilege}:
    \begin{itemize}
        \item \textit{Threat}: Accessing administrative or other users' data.
        \item \textit{Mitigation}: Route segregation in the API Gateway. The \texttt{user-manager} enforces ownership checks (users can only edit their own profile).
    \end{itemize}
\end{itemize}

