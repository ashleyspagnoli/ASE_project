\section{Security}

\subsection{Security – Data}

\subsubsection{Input Sanitization}

\textbf{Selected Input:} User email addresses during registration and modification.

\paragraph{Description:}
The email input is a critical user identifier used for account recovery and communication. It must be sanitized to prevent:
\begin{itemize}
    \item NoSQL injection attacks
    \item Cross-site scripting (XSS) attempts
    \item Duplicate account creation
\end{itemize}

\paragraph{Microservices Involved:}
\begin{itemize}
    \item \textbf{User-Manager:} Handles registration and email validation
    \item \textbf{User-Editor:} Manages email modification requests
    \item \textbf{API Gateway:} Performs initial validation before forwarding requests
\end{itemize}

\paragraph{Sanitization Strategy:}

\textbf{Type Validation:}
\begin{lstlisting}
class UserCreate(UserBase):
    password: str = Field(..., min_length=3)
    email: str = Field(..., description="User's email")
\end{lstlisting}

\textbf{Hash-based Duplicate Prevention:}
\begin{lstlisting}
def hash_search_key(data: str) -> str:
    """SHA-256 hash for consistent, secure searching"""
    return hashlib.sha256(data.lower().encode('utf-8')).hexdigest()

# Usage in registration
hashed_email = hash_search_key(user_in.email)
if USERS_COLLECTION.find_one({"hashed_email": hashed_email}):
    raise HTTPException(status_code=400, 
                       detail="Email already registered")
\end{lstlisting}

\textbf{Query Parameter Validation:}
\begin{lstlisting}
# Explicit type enforcement prevents injection
page = request.args.get('page', default=0, type=int)
\end{lstlisting}

\subsubsection{Data Encryption at Rest}

\paragraph{Encrypted Data:}
To protect confidentiality in case of database compromise email addresses and usernames in user-db have been encrypted at rest. 

\paragraph{Encryption Implementation:}

\textbf{Encryption Method:} Fernet

\textbf{Key Management:}
\begin{itemize}
    \item Encryption key stored as Docker secret at \texttt{/run/secrets/user\_db\_encryption\_secret\_key}
    \item Generated using cryptographically secure random bytes (32 bytes/256 bits)
    \item Encoded in Base64 URL-safe format for compatibility
\end{itemize}

\textbf{Encryption Location:} \texttt{user-manager} microservice

\textbf{Usage in Data Storage:}
\begin{lstlisting}
# main.py - User registration
user_data = {
    "username": user_in.username,
    "email": encrypt_data(user_in.email),  # Encrypted before storage
    "hashed_password": get_password_hash(user_in.password),
    "hashed_email": hash_search_key(user_in.email)
}
USERS_COLLECTION.insert_one(user_data)
\end{lstlisting}

\textbf{Decryption Location:} \texttt{user-manager} microservice (during token validation and user data retrieval)

\begin{lstlisting}
# Automatic decryption when retrieving user data
user = UserInDB(
    username=user_doc['username'],
    email=decrypt_data(user_doc['email']),  # Decrypted on read
    hashed_password=user_doc['hashed_password']
)
\end{lstlisting}

\paragraph{Reasons:}
\begin{itemize}
    \item \textbf{Defense in Depth:} Even if the database is compromised, sensitive data remains encrypted
    \item \textbf{Dual Hashing Strategy:} Email addresses are both encrypted (for storage) and hashed (for duplicate checking), preventing inference attacks
    \item \textbf{Separation of Concerns:} Encryption keys are managed externally via Docker secrets
\end{itemize}

\newpage
\subsection{Security – Authentication and Authorization}

\subsubsection{Architecture: Centralized Authentication}

Our system implements a \textbf{centralized authentication model} where the \texttt{user-manager} microservice acts as the single source of truth for authentication and token validation.

\paragraph{Token Validation Flow:}

\begin{enumerate}
    \item \textbf{Client Request:} User sends credentials to API Gateway
    \item \textbf{Authentication:} API Gateway forwards to \texttt{user-manager}
    \item \textbf{Token Generation:} \texttt{user-manager} creates JWT and returns to client
    \item \textbf{Subsequent Requests:} Client includes JWT in Authorization header
    \item \textbf{Token Validation:} Each microservice calls \texttt{user-manager} to validate token
    \item \textbf{Authorization:} Microservice proceeds with request if token is valid
\end{enumerate}

\begin{figure}[h]
\centering
\begin{minipage}{0.9\textwidth}
\textbf{Token Validation Process:}
% \begin{verbatim}
% ┌─────────┐        ┌─────────────┐        ┌──────────────┐
% │ Client  │───1───>│ API Gateway │───2───>│ Microservice │
% └─────────┘        └─────────────┘        └──────────────┘
%      │                                            │
%      │                                            │3. Validate
%      │                                            ▼
%      │                                     ┌──────────────┐
%      │<──────────────6. Response──────────│ user-manager │
%      │                                     └──────────────┘
%      │                                            │
%      │                                            │4. JWT decode
%      │                                            │5. DB lookup
% \end{verbatim}
\end{minipage}
\caption{Centralized token validation architecture}
\end{figure}

\paragraph{Key Management and Storage:}

\begin{table}[h]
\centering
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Aspect} & \textbf{Implementation} \\ \midrule
\textbf{Signing Key} & 256-bit secret key (HS256 algorithm) \\
\textbf{Storage Location} & Docker secret: \texttt{/run/secrets/jwt\_secret\_key} \\
\textbf{Access Control} & Only \texttt{user-manager} container has read access \\
\textbf{Generation} & Cryptographically secure random bytes (Base64 URL-safe) \\
\textbf{Rotation Strategy} & Manual rotation via Docker secret update and container restart \\ \bottomrule
\end{tabular}
\caption{JWT signing key management}
\end{table}

\subsubsection{Access Token Payload Format}

\begin{lstlisting}
{
  "sub": "username",                 # Subject (username identifier)
  "username": "john_doe",            # Explicit username field
  "id": "507f1f77bcf86cd799439011",  # MongoDB ObjectId
  "exp": 1735220400                  # Expiration timestamp (Unix epoch)
}
\end{lstlisting}

\textbf{Field Descriptions:}
\begin{itemize}
    \item \texttt{sub}: Standard JWT subject claim containing the username
    \item \texttt{username}: Redundant field for backward compatibility
    \item \texttt{id}: User's unique database identifier for efficient lookups
    \item \texttt{exp}: Expiration timestamp (30 minutes from issuance)
\end{itemize}

\subsubsection{Token Generation Process}

\begin{lstlisting}
def create_access_token(data: dict):
    to_encode = data.copy()
    # Ensure 'sub' claim for OAuth2 compatibility
    if "sub" not in to_encode and "username" in to_encode:
        to_encode["sub"] = to_encode["username"]
    
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
\end{lstlisting}

\subsubsection{Expired Token Handling}

\paragraph{Strategy:} \textbf{Automatic rejection with explicit error messaging}

\textbf{Mechanism:}
\begin{enumerate}
    \item JWT library (\texttt{python-jose}) automatically validates \texttt{exp} claim during decoding
    \item \texttt{JWTError} exception is raised if token is expired
    \item Client receives HTTP 401 Unauthorized response
    \item Client must re-authenticate to obtain new token
\end{enumerate}

\begin{lstlisting}
def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid credentials",
        headers={"Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:  # Catches ExpiredSignatureError automatically
        raise credentials_exception
    
    user = get_user(username)
    if user is None:
        raise credentials_exception
    return user
\end{lstlisting}

\textbf{Client-Side Handling:}
\begin{itemize}
    \item Client detects 401 response
    \item Redirects user to login page
    \item Clears stored token from local state
    \item User re-authenticates to receive fresh token
\end{itemize}

\textbf{No Token Refresh Mechanism:}
For simplicity and security, we do not implement refresh tokens. Users must re-authenticate after 30 minutes of inactivity. This reduces the attack surface by limiting token lifetime.

\newpage
\subsection{Security – Analyses}

\subsubsection{Static Analysis with Bandit}

Bandit was used to perform static application security testing on the Python codebase.

\textbf{Command executed:}
\begin{lstlisting}
bandit -r src/
\end{lstlisting}

% Da aggiungre screenshot del report di Bandit
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{bandit_report.png}
% \caption{Bandit static analysis final summary}
% \end{figure}

\subsubsection{Dependency Vulnerability Scanning}

\paragraph{Pip Audit:}
\begin{lstlisting}
pip-audit
\end{lstlisting}

\textbf{Result:} One low-severity vulnerability found in pip version 24.0, fixed upgrading it to 25.3.

\paragraph{Dependabot (GitHub):}
Enabled on the repository to automatically scan for vulnerable dependencies.

\textbf{Result:} No vulnerabilities detected in production dependencies.

\subsubsection{Container Image Vulnerability Analysis}

\paragraph{Docker Scout:}

\textbf{Usage:} all container images where scanend for vulnerabilities using Docker Scout directly from Docker Desktop.

\textbf{Mitigation Actions:}
\begin{itemize}
    \item \textbf{RabbitMQ:} 2 critical, 9 high-severity vulnerabilities because of the golang and stdlib versions in the linux image used by 3-management. Solved upgrading to \texttt{rabbitmq:4.2.1-alpine}.
    \item \textbf{MongoDB:}
    This was more of an issue, 
    \begin{itemize}
        \item The mongo:latest image we used in development had 6 high-severity vulnerabilities.
        \item All the versions of the official mongo image have either a lot of vulnerabilities or run only on windows servers (windows OS images).
        \item "latest" images are not an option as a final shipment version, this would mean the images possibly breaking for an update.
        \item All the companies we've found providing mongo linux images moved to a paid model, providing only "latest" versions for free for development environments.
        \item The only option we had were old legacy images made by those companies in the past.
        Fortunately we found \textit{circleci/mongo:4.0-xenial-ram},
        a 4 years old image that relied on a really light-weight ubuntu version with 0 vulnerabilities.
        \item This is definitely not a future-proof solution, hence the best path forward might just be to build a local image where we install mongoDB on top of alpine.
    \end{itemize}
\end{itemize}

% Da aggiungere screenshot del report di Docker Scout
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{docker_scout_dashboard.png}
% \caption{Docker Scout vulnerability dashboard}
% \end{figure}

\paragraph{Trivy:}

\textbf{Command executed:}
\begin{lstlisting}
trivy image --severity HIGH,CRITICAL <image_name>
\end{lstlisting}

\textbf{Findings:}
\begin{itemize}
    \item \textbf{Exposed Secrets:} Trivy detected hardcoded keys in repository
    \item \textbf{Academic Context:} Keys are intentionally included for educational demonstration purposes
    \item \textbf{Production Mitigation:} In a real deployment, keys would be:
    \begin{itemize}
        \item Generated dynamically per environment
        \item Stored in secure secret management systems
        \item Never committed to version control
    \end{itemize}
\end{itemize}


\subsection{Security – Threat Model}