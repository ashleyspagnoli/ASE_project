\section{Security}

\subsection{Security – Data}

\subsubsection{Input Sanitization}
\textbf{Target:} User email addresses (Registration/Modification).

\textbf{Threats Mitigated:} NoSQL injection, XSS, Duplicate accounts.

\textbf{Implementation:}
\begin{itemize}
    \item \textbf{Type Validation:} Pydantic models enforce strict typing (e.g., \texttt{email: str}).
    \item \textbf{Duplicate Prevention:} SHA-256 hashing of emails for secure, consistent search keys without exposing raw data.
    \item \textbf{Query Safety:} Explicit type casting of query parameters (e.g., \texttt{page=int}) to prevent injection.
\end{itemize}

\subsubsection{Data Encryption at Rest}
\textbf{Scope:} Sensitive user data (Email, Username) in \texttt{user-db}.

\textbf{Mechanism:}
\begin{itemize}
    \item \textbf{Algorithm:} Fernet (Symmetric encryption).
    \item \textbf{Key Management:} 32-byte cryptographically secure key, stored as Docker secret (\texttt{/run/secrets/user\_db\_encryption\_secret\_key}).
    \item \textbf{Process:} 
    \begin{itemize}
        \item \textbf{Write:} Encrypt data before insertion.
        \item \textbf{Read:} Decrypt data on retrieval.
        \item \textbf{Search:} Use hashed values for lookups to avoid decrypting entire collections.
    \end{itemize}
\end{itemize}

\subsection{Security – Authentication and Authorization}

\subsubsection{Architecture}
\textbf{Model:} Centralized Authentication via \texttt{user-manager}.

\textbf{Flow:}
\begin{enumerate}
    \item \textbf{Login:} Client credentials $\rightarrow$ API Gateway $\rightarrow$ \texttt{user-manager} $\rightarrow$ JWT issued.
    \item \textbf{Access:} Client sends JWT $\rightarrow$ Microservice $\rightarrow$ Validate with \texttt{user-manager}.
\end{enumerate}

\subsubsection{JWT Implementation}
\textbf{Configuration:}
\begin{itemize}
    \item \textbf{Algorithm:} HS256.
    \item \textbf{Secret Storage:} Docker secret (\texttt{/run/secrets/jwt\_secret\_key}), accessible only to \texttt{user-manager}.
    \item \textbf{Payload:}
    \begin{itemize}
        \item \texttt{sub}: Username (Subject).
        \item \texttt{id}: Database ObjectId.
        \item \texttt{exp}: Expiration timestamp (30 minutes).
    \end{itemize}
\end{itemize}

\subsubsection{Token Lifecycle}
\begin{itemize}
    \item \textbf{Validation:} \texttt{pyJWT} library automatically verifies signature and expiration.
    \item \textbf{Expiration Policy:} For simplicity and security, we do not implement refresh tokens. Users must re-authenticate after 30 minutes of inactivity. This reduces the attack surface by limiting token lifetime.
    \item \textbf{Error Handling:} Expired/Invalid tokens return HTTP 401, triggering client-side logout.
\end{itemize}

\newpage
\subsection{Security – Analyses}

\subsubsection{Static Analysis with Bandit}

Bandit was used to perform static application security testing on the Python codebase.

\textbf{Command executed:}
\begin{lstlisting}
bandit -r src/
\end{lstlisting}
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{images/bandit.png}
\end{figure}

% Da aggiungre screenshot del report di Bandit
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{bandit_report.png}
% \caption{Bandit static analysis final summary}
% \end{figure}

\subsubsection{Dependency Vulnerability Scanning}

\paragraph{Pip Audit:}
Executed as a github action.
It found vulnerabilities before but not after merging the Dependabot pull request.

\paragraph{Dependabot (GitHub):}
Enabled on the repository to automatically scan for vulnerable dependencies.

\begin{itemize}
    \item Updates python-multipart from 0.0.9 to 0.0.18
    \item Updates requests from 2.31.0 to 2.32.4
    \item Updates cryptography from 42.0.7 to 44.0.1
\end{itemize}
This also solved issues raised by pip-audit

\subsubsection{Container Image Vulnerability Analysis}

\paragraph{Docker Scout:}

\textbf{Usage:} all container images where scanend for vulnerabilities using Docker Scout directly from Docker Desktop.

\textbf{Mitigation Actions:}
\begin{itemize}
    \item \textbf{RabbitMQ:} 2 critical, 9 high-severity vulnerabilities because of the golang and stdlib versions in the linux image used by 3-management. Solved upgrading to \texttt{rabbitmq:4.2.1-alpine}.
    \item \textbf{MongoDB:}
    This was more of an issue, 
    \begin{itemize}
        \item The mongo:latest image we used in development had 6 high-severity vulnerabilities.
        \item All the versions of the official mongo image have either a lot of vulnerabilities or run only on windows servers (windows OS images).
        \item "latest" images are not an option as a final shipment version, this would mean the images possibly breaking for an update.
        \item All the companies we've found providing mongo linux images moved to a paid model, providing only "latest" versions for free for development environments.
        \item The only option we had were old legacy images made by those companies in the past.
        Fortunately we found \textit{circleci/mongo:4.0-xenial-ram},
        a 4 years old image that relied on a really light-weight ubuntu version with 0 vulnerabilities.
        \item This is definitely not a future-proof solution. The best path forward would probably be to build a custom image where we install mongoDB on top of a lightweight alpine or debian image.
    \end{itemize}
    \item \textbf{JWT:} The User Manager microservice used an abandoned library to handle the JWT called python-jose with a high severity vulnerability. Fortunately there was a new and updated library that had the same functions, called PyJWT.
    \item FastAPI 0.111.0 has critical vulnerabilities caused by a starlette dependency. Solved by upgrading to 0.124.4.
    \item python:3.12.3-slim has critical vulnerabilities caused by the debian image used. Solved by upgrading to 3.12.12-slim.
\end{itemize}

% Da aggiungere screenshot del report di Docker Scout
% \begin{figure}[h]
% \centering
% \includegraphics[width=0.95\textwidth]{docker_scout_dashboard.png}
% \caption{Docker Scout vulnerability dashboard}
% \end{figure}

\paragraph{Trivy:}

\textbf{Command executed:}
\begin{lstlisting}
trivy image --severity HIGH,CRITICAL <image_name>
\end{lstlisting}

\textbf{Findings:}
\begin{itemize}
    \item \textbf{Exposed Secrets:} Trivy detected hardcoded keys in repository
    \item \textbf{Academic Context:} As agreed with the Professor, keys are intentionally included since it's a project with educational purposes.
    \item \textbf{Production Mitigation:} In a real deployment, keys would be:
    \begin{itemize}
        \item Generated dynamically per environment or, even better, we could've used certificates provided by a CA.
        \item Stored in secure secret management systems
        \item Never committed
    \end{itemize}
    The same principles would apply for databases passwords hardcoded in the docker compose file.
\end{itemize}


\subsection{Security – Threat Model}

\subsubsection{Architecture Overview}
The application follows a microservices architecture with a centralized API Gateway acting as the single entry point. All inter-service communication is secured via TLS.

\begin{itemize}
    \item \textbf{External Entry Point:} API Gateway (exposed on port 8443).
    \item \textbf{Internal Services:} User Manager, User Editor, Game Engine, Game History, Collection.
    \item \textbf{Data Stores:} Dedicated MongoDB instances for Users, History, and Decks.
    \item \textbf{Messaging:} RabbitMQ for asynchronous communication, configured to reject non-TLS connections.
\end{itemize}

\subsubsection{Assets Identification}
\begin{itemize}
    \item \textbf{User Credentials:} Passwords (hashed) and Emails (encrypted).
    \item \textbf{Session Tokens:} JWTs used for authentication.
    \item \textbf{Game Data:} Match history and player moves.
    \item \textbf{Infrastructure Secrets:} TLS certificates and private keys managed via Docker Secrets.
\end{itemize}

\subsubsection{STRIDE Analysis}

\paragraph{Spoofing}
\begin{itemize}
    \item \textbf{Threat:} An attacker impersonating a legitimate user.
    \item \textbf{Mitigation:} Strong authentication via \texttt{user-manager}, JWT validation on every request, and TLS for all connections to prevent credential interception.
    \item \textbf{Threat:} A rogue service impersonating a legitimate microservice.
    \item \textbf{Mitigation:} Internal TLS usage with certificates managed via Docker Secrets ensures encrypted communication channels.
\end{itemize}

\paragraph{Tampering}
\begin{itemize}
    \item \textbf{Threat:} Modification of game results or user data in transit.
    \item \textbf{Mitigation:} End-to-end TLS encryption prevents Man-in-the-Middle (MitM) attacks.
    \item \textbf{Threat:} Modification of data at rest.
    \item \textbf{Mitigation:} Critical user data (emails) is encrypted at rest. Database access is restricted to specific microservices.
\end{itemize}

\paragraph{Repudiation}
\begin{itemize}
    \item \textbf{Threat:} A user denying they performed an action (e.g., a game move).
    \item \textbf{Mitigation:} The \texttt{game\_history} service logs all match outcomes. Actions are authenticated via JWT, linking them irrefutably to a user ID.
\end{itemize}

\paragraph{Information Disclosure}
\begin{itemize}
    \item \textbf{Threat:} Leaking sensitive user information.
    \item \textbf{Mitigation:} Data minimization (only necessary data returned), encryption of sensitive fields in DB, and strict API Gateway routing preventing direct access to backend services.
\end{itemize}

\paragraph{Denial of Service (DoS)}
\begin{itemize}
    \item \textbf{Threat:} Overwhelming the system with requests.
    \item \textbf{Mitigation:} The API Gateway acts as a buffer. RabbitMQ decouples heavy processing (like history logging) from the critical path, preventing cascading failures.
\end{itemize}

\paragraph{Elevation of Privilege}
\begin{itemize}
    \item \textbf{Threat:} A regular user accessing administrative functions.
    \item \textbf{Mitigation:} Centralized authorization logic in \texttt{user-manager}. The API Gateway enforces route restrictions.
\end{itemize}

