\section{Additional Features}
%3 user stories verdi, client, salvataggio deck in collection, uso di rabbitmq come proof of concept

\subsection{Green User Stories}
\label{sec:green-user-stories}

The project implements two green user stories that enhance the player's gameplay experience by providing essential game state information.

\subsubsection{Viewing Cards in Hand}
\begin{itemize}
    \setcounter{usCounter}{21}
    \item[\colorednum{green}{2}] who's turn it is SO THAT I know if i can play or not
    \begin{itemize}
        \item \texttt{GET /state/\{game\_id\}} (Gateway $\rightarrow$ Game Engine $\rightarrow$ Gateway)
        \item Response: current round state (empty, one card played, both cards played)
    \end{itemize}
    \setcounter{usCounter}{23}
    \item[\colorednum{green}{1}] To be able to see the cards in my hand	SO THAT	I know that card I can play next

    \begin{itemize}
        \item \texttt{GET /hand/\{game\_id\}} (Gateway $\rightarrow$ Game Engine $\rightarrow$ Gateway)
        \item Returns: JSON array of card objects (\texttt{value}, \texttt{suit})
    \end{itemize}

\end{itemize}

\subsection{Cloud Storage of Decks}
\label{sec:cloud-decks}
To allow players to keep their decks stored in the cloud, we modified the way they handle decks.\\
Users must first create the decks connecting to the endpoint \texttt{collection/decks}. They have 5 slots (5 possible decks).\\
Then that deck will be stored on the decks database.\\
Users will then be able to choose one of their decks when starting a game with the endpoint \texttt{game/match/join}.

\subsection{Client}
The project includes a Python-based Command Line Interface (CLI) client located in the \texttt{/client} directory. This client serves as the frontend for the game, communicating with the backend services via the API Gateway. It uses the \texttt{rich} and \texttt{questionary} libraries to provide an interactive terminal experience.

To run the client using Docker, execute the following command (Linux):
\begin{lstlisting}
cd client/
docker build -t ase-client . --no-cache
docker run -it --rm \
  --add-host=host.docker.internal:host-gateway \
  -e API_GATEWAY_URL="https://host.docker.internal:8443/" \
  -e GATEWAY_CERT_PATH="./gateway_cert.pem" \
  ase-client
\end{lstlisting}
Ensure that the backend services are running before starting the client.

\subsubsection{User Authentication}
\begin{itemize}
    \item \textbf{Login/Register:} Users are prompted to authenticate via the API Gateway and Authentication microservice upon startup.
    \item \textbf{Token Management:} The client locally stores the username and JWT token. The token is included in the headers of every request (defined in \textbf{$``$apicalls.py$``$}).
    \item \textbf{Prerequisite:} Users must navigate to \textbf{$``$Decks$``$} to create at least one deck before playing.
\end{itemize}

\subsubsection{Card Collection and Deck Management}
\begin{itemize}
    \item \textbf{Capabilities:} Users can view the collection, create new decks (Deck Page), view existing decks, and delete decks (View Deck).
    \item \textbf{Visuals:} Selecting a card in the local version opens its image in a new window (not in Containerized version).
    \item \textbf{Deck Creation:} Simplified logic grants the maximum value for every suit during creation.
\end{itemize}

\subsubsection{Game Engine Interaction}
\begin{itemize}
    \item \textbf{Testing Setup:} Requires two terminal instances logged in with different user accounts.
    \item \textbf{Matchmaking:} Select \textbf{$``$Play a Match$``$} to enter the queue and await an opponent.
    \item \textbf{Gameplay:} The interface displays real-time game state (hand, scores, opponent name) and enables interactive card play per turn.
    \item \textbf{Conclusion:} Displays final results and automatically updates the user's game history.
\end{itemize}

\subsubsection{Game History}
\begin{itemize}
    \item \textbf{Access:} Located within the \textbf{$``$Leaderboard$``$} section of the main menu.
    \item \textbf{Options:} Users can toggle between the full Global Leaderboard and their Personal Match History.
    \item \textbf{Navigation:} The leaderboard includes a pagination system to browse all players.
\end{itemize}

\subsection{Endpoint-based Service Interaction Smell - Proof of Concept} %RabbitMQ
\label{sec:rabbitmq}
The project requirements asked to make up for the \textbf{Wobbly service interaction} smell. We solved it mainly with timeouts as suggested.\\
Regarding the \textbf{Endpoint-based service interaction} smell, the requirements said to ignore it since it would've been difficult to solve.\\
We decided to partially solve it anyway in a single interaction between the \textbf{Game History} and \textbf{Game Engine} microservices as a proof-of-concept.\\
In this interaction we replaced the timeout with RabbitMQ, a Message Broker, that solved both the \textbf{Wobbly service interaction} and the \textbf{Endpoint-based service interaction} smells.
This meant a new docker container for RrabbitMQ and running code to fill up the RabbitMQ queue in Game Engine and to ping it for new data in Game History.
\subsection{Test-match}
As already said in \hyperref[sec:test-match]{Test Match} we made a simple script to test the system. You can find it in \texttt{/docs/tests/test\_match.py}.

\subsection{pip-audit Actions}
Together with the actions for unit tests and integration tests, we implemented a GitHub Action that runs \texttt{pip-audit} to automatically check for known vulnerabilities in our Python dependencies.

